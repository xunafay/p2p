use std::{
    collections::{HashMap, HashSet, VecDeque},
    convert::Infallible,
    hash::Hash,
    path::{Path, PathBuf},
};

use automerge::AutoCommit;
use either::Either::{self, Left};
use libp2p::{
    PeerId,
    swarm::{ConnectionId, NetworkBehaviour, NotifyHandler, ToSwarm, dummy},
};

use crate::handler::{Command, Handler, InEvent};

/// Event generated by the Automerge behaviour
#[derive(Debug)]
pub enum Event {
    DocumentSynced {
        peer: PeerId,
        document_id: String,
    },
    DocumentChanged {
        document_id: String,
    },
    SyncRequested {
        peer: PeerId,
        document_id: String,
    },
    SyncStarted {
        peer: PeerId,
        document_id: String,
    },
    SyncFinished {
        peer: PeerId,
        document_id: String,
    },
    SyncError {
        peer: PeerId,
        document_id: String,
        error: String,
    },
}

#[derive(Debug)]
pub struct Config {
    pub max_simultaneous_syncs: usize,
    pub documents_whitelist: Option<Vec<String>>,
    pub data_dir: PathBuf,
}

pub struct Behaviour {
    /// Events to be sent to the handler
    queued_events: VecDeque<ToSwarm<Event, InEvent>>,
    active_syncs: HashMap<PeerId, HashSet<ConnectionId>>,
    /// Pending commands to send to connection handlers
    pending_commands: HashMap<(PeerId, String), VecDeque<Command>>,
    config: Config,
    documents: HashMap<String, automerge::AutoCommit>,
}

impl Behaviour {
    pub fn new(config: Config) -> Self {
        let mut behaviour = Behaviour {
            queued_events: VecDeque::new(),
            active_syncs: HashMap::new(),
            pending_commands: HashMap::new(),
            config,
            documents: HashMap::new(),
        };

        behaviour.initialize_config_documents();
        behaviour.write_all_documents();
        behaviour
    }

    pub fn modify_document<F>(&mut self, document_id: &str, f: F)
    where
        F: FnOnce(&mut AutoCommit),
    {
        if let Some(doc) = self.documents.get_mut(document_id) {
            f(doc);

            let commit = doc.commit();
            tracing::debug!("Document {} modified, new heads: {:?}", document_id, commit);

            self.write_to_disk(document_id);
            self.notify_document_changed(document_id.to_string());
        }
    }

    pub fn get_document(&self, document_id: &str) -> Option<&AutoCommit> {
        self.documents.get(document_id)
    }

    /// Notify all other connected peers via that a document has changed
    fn notify_document_changed(&mut self, document_id: String) {
        for (peer_id, connection_ids) in &self.active_syncs {
            let Some(connection_id) = connection_ids.iter().next() else {
                continue;
            };

            tracing::debug!(
                "Notifying peer {} of document change {} on connection {}",
                peer_id,
                document_id.clone(),
                connection_id
            );
            self.queued_events.push_back(ToSwarm::NotifyHandler {
                peer_id: *peer_id,
                handler: NotifyHandler::One(*connection_id),
                event: InEvent::DocumentChanged {
                    document_id: document_id.clone(),
                },
            });
        }
    }
}

impl Behaviour {
    fn initialize_config_documents(&mut self) {
        let Some(whitelist) = &self.config.documents_whitelist else {
            return;
        };

        for doc_id in whitelist {
            if let Some(doc) = self.read_from_disk(doc_id) {
                self.documents.insert(doc_id.clone(), doc);
                continue;
            };

            tracing::debug!("Creating new document {}", doc_id);
            self.documents
                .entry(doc_id.clone())
                .or_insert_with(|| automerge::AutoCommit::new());
        }
    }

    fn read_from_disk(&self, _document_id: &str) -> Option<AutoCommit> {
        if self.documents.contains_key(_document_id) {
            return None;
        }

        if let Ok(bytes) = std::fs::read(format!("./data/{}.automerge", _document_id)) {
            if let Ok(doc) = automerge::AutoCommit::load(&bytes) {
                tracing::debug!("Loaded document {} from disk", _document_id);
                return Some(doc);
            }
        }

        None
    }

    fn write_all_documents(&mut self) {
        for document_id in self.documents.keys().cloned().collect::<Vec<_>>() {
            self.write_to_disk(&document_id);
        }
    }

    fn write_to_disk(&mut self, _document_id: &str) {
        self.documents.get_mut(_document_id).map(|doc| {
            let bytes = doc.save();
            std::fs::create_dir_all(self.config.data_dir.clone()).ok();
            std::fs::write(
                self.config
                    .data_dir
                    .join(format!("{}.automerge", _document_id)),
                bytes,
            )
            .ok();
        });
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = Handler;

    type ToSwarm = Event;

    fn handle_established_inbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        _local_addr: &libp2p::Multiaddr,
        _remote_addr: &libp2p::Multiaddr,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        tracing::warn!("Established inbound connection: {:?}", peer);
        self.active_syncs
            .entry(peer)
            .or_insert_with(HashSet::new)
            .insert(connection_id);
        Ok(crate::handler::Handler::new())
    }

    fn handle_established_outbound_connection(
        &mut self,
        connection_id: libp2p::swarm::ConnectionId,
        peer: libp2p::PeerId,
        _addr: &libp2p::Multiaddr,
        _role_override: libp2p::core::Endpoint,
        _port_use: libp2p::core::transport::PortUse,
    ) -> Result<libp2p::swarm::THandler<Self>, libp2p::swarm::ConnectionDenied> {
        tracing::warn!(
            "Established outbound connection: {:?} {:?}",
            peer,
            connection_id
        );
        self.active_syncs
            .entry(peer)
            .or_insert_with(HashSet::new)
            .insert(connection_id);
        Ok(crate::handler::Handler::new())
    }

    fn on_swarm_event(&mut self, event: libp2p::swarm::FromSwarm) {
        match event {
            libp2p::swarm::FromSwarm::ConnectionClosed(e) => {
                tracing::debug!("Connection closed: {:?} {:?}", e.peer_id, e.connection_id);
                if let Some(conns) = self.active_syncs.get_mut(&e.peer_id) {
                    conns.retain(|&id| id != e.connection_id);
                    if conns.is_empty() {
                        self.active_syncs.remove(&e.peer_id);
                    }
                }
            }
            _ => {}
        }
    }

    fn on_connection_handler_event(
        &mut self,
        _peer_id: libp2p::PeerId,
        _connection_id: libp2p::swarm::ConnectionId,
        event: libp2p::swarm::THandlerOutEvent<Self>,
    ) {
        tracing::warn!("Connection event: {:?}", event);
        match event {
            _ => {
                tracing::warn!("Unhandled handler event: {:?}", event);
            }
        }
    }

    fn poll(
        &mut self,
        _cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<ToSwarm<Self::ToSwarm, libp2p::swarm::THandlerInEvent<Self>>> {
        if let Some(event) = self.queued_events.pop_front() {
            return std::task::Poll::Ready(event);
        } else if self.queued_events.capacity() > 100 {
            self.queued_events.shrink_to_fit();
        }

        std::task::Poll::Pending
    }
}
